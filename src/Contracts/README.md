# **Writing a Jambhala Plutus Contract**

## **0. Create Module & Declare Imports**
  * 0a. Create a new `.hs` file (beginning with a capital letter) in the `src/Contracts` directory.
  * 0b. Declare your module header (`module Contracts.MyContract where`, where `MyContract` is the name of your `.hs` file).
  * 0c. Open the `.cabal` file found in the root directory and add `Contracts.MyContract` to the `exposed-modules` section of the `library` stanza (where `MyContract` is your contract's module name).
  * 0d. Stage the new module file with `git` (by calling `git add src/Contracts/MyContract.hs` in the terminal, or using the VSC Source Control tab).
  * 0e. In your contract's `.hs` module file, `import Jambhala.Plutus` to utilize common values, functions and types from Plutus libraries, and `import Jambhala.Utils` to utilize Jambhala utility functions and framework-specific types.

## **1. Declare Types**
  * 1a. Define any required custom data types for datum and/or redeemer.
  * 1b. Generate `ToData`/`FromData` instances for the above types via Template Haskell.
  * **For parameterized scripts:**
    * 1c. Define custom data type(s) for any extra script parameter(s).
    * 1d. Generate `Lift` instance(s) for the above via Template Haskell.
  ### **Recap:**
  * Custom data types can be declared for the **datum** and **redeemer** values, as well as any extra parameters, which will ultimately serve as the inputs on which the Plutus script is executed.
  * These arbitrary types must be convertible to and from a dynamic data type called *`BuiltinData`*, which is the only type of data accepted by the Plutus pre-compiler.
  * Instances of two typeclasses (*`ToData`*, *`FromData`*) provide this convertibility, and their code is generated by a snippet of Template Haskell.

## **2. Define Lambda**
  * 2a. Define the function ("lambda") containing the script logic.
  * 2b. If using types, convert the lambda to its untyped counterpart.
  ### **Recap:**
  * A **lambda** in Jambhala discourse refers to a PlutusTx script function in its uncompiled form.
  * Although defined as a named function, they're referred to as lambdas for a couple of reasons: 
    * Other terms like "script", "validator", or "policy" are too ambiguous: they could refer to the uncompiled function defining the script's logic, or the compiled UPLC output, or some Haskell type wrapping the latter.
    * Ultimately named script functions are pre-compiled into anonymous bytestrings of UPLC code executed by Cardano nodes, and have no on-chain identity apart from the script address that results from hashing their contents.
  * A contract's lambda:
    * is defined as a Haskell *predicate* (expression returning a *`Bool`* value).
    * defines the on-chain logic of the script, which determines whether the transaction executing the script will succeed or fail.
    * is parameterized by inputs (the mandatory inputs for the script, optionally preceeded by additional user-defined parameters).
      * Mandatory inputs for all scripts are the **redeemer** and **script context**. 
      * Spending validators require an additional **datum** parameter that precedes the redeemer.
  * Lambdas may include "typed" parameters (input parameters with types other than the Plutus *`BuiltinData`* type), but must ultimately be converted into "untyped" form before pre-compilation.
  * The lambda is consumed by the PlutusTx compiler to generate a raw UPLC bytestring, which is then spliced back into Haskell and wrapped in a Haskell datatype to facilitate interaction with other Haskell code within the project.

## **3. Pre-Compile Lambda**
  * 3a. Declare a Jambhala **contract synonym** for the compiled script.
  * 3b. Define a **compilation expression** to pre-compile the Jambhala contract using Template Haskell and the appropriate Jambhala wrapper function (`mkValidatorContract` or `mkMintingContract`). 
    * For non-parameterized scripts, the compilation expression defines a constant value (with its type being the contract synonym declared above).
    * For parameterized scripts, the compilation expression is a function that receives the extra parameter(s) and returns a value of the contract synonym.
    * A type signature terminating in the contract synonym must always be included with the compilation expression, in order to "tag" the resulting compiled script value with the contract's symbolic identifier. This is critical to how the Jambhala framework understands the identities of individual contracts and augments them with additional functionality via the `jamb` CLI.
  ### **Recap:**
  * A **contract synonym** serves as a unique type-level identifier for a specific Jambhala contract.
  * Can be thought of like a contract's "nametag", which is used internally by the Jambhala framework.
  * Contract synonyms consist of the following:
    * Left-hand-side: the `type` keyword followed by the synonym (the type that will be used to reference the contract in type signatures and annotations)
    * Right-hand-side: a Jambhala contract type constructor (*`ValidatorContract`* or *`MintingContract`*) followed by a unique (type-level) string literal (*`Symbol`*), which serves as the contract's unique identifier. Another Jambhala term for this string is the contract's **symbolic identifier**. It can be any string, provided it hasn't been used for any other contracts in the same project.
  * The contract synonym is the *return type* for a compiled Jambhala contract.
  * Pre-compilation from PlutusTx (Haskell) to UPLC (and re-insertion as a Haskell value) occurs via the **compilation expression**: a constant value (for non-parameterized scripts) or function (for parameterized scripts) that returns a value with type equal to the contract synonym.
  * Pre-compilation of a Jambhala contract consists of two steps:
    1. Pre-compilation from PlutusTx (Haskell) code to Untyped Plutus Core (UPLC) via Template Haskell.
    2. Conversion of pre-compiled code to a Jambhala contract value.

## **4. Export Contract to Jambhala**
* 4a. An `exports` value is defined of type *`JambExports`*. 
* 4b. The default exports value boilerplate is defined as:
  ```haskell
  exports :: JambExports
  exports = export
    (defExports _COMPILED_SCRIPT_)
  ```
  * `_COMPILED_CONTRACT_` is whichever variable is assigned to the contract's pre-compiled script value.
  * The default exports consist of just the compiled script and its symbolic identifier.
* 4c. The exports can optionally be extended to include **data exports** and an **emulator test**.
  * Data exports are a list of specific sample input values (to be used in JSON format as datums or redeemers in off-chain transaction construction with `cardano-cli`).
  * Each of these values will be serialised to JSON format and written to a `.json` file when running the `jamb -w` command in terminal.
  * Any value with a *`ToData`* instance can be converted to a value of type *`DataExport`* by applying the `toJSONfile` utility to it along with a string containing the desired `.json` filename.
  * Extension of default imports is achieved via *record update syntax*, adding curly braces containing named selector values, following the closing parentheses in the default exports boilerplate above:
    ```haskell
    exports :: JambExports
    exports = export
      (defExports _COMPILED_SCRIPT_) 
        { dataExports = [...list DataExport values here...],
          emulatorTest = myTest
        }
    ```
  * Emulator tests can be added as an optional component (explained in the next section).
* 4d. Add contract to the `Contracts.hs` module located in the `src` directory.
  * Import your module, qualifying it with an alias (`import Contracts.MyContract qualified as MyContract`).
  * Add `MyContract.exports` to the `contracts` list.
  * The contract can now be used with the `jamb` CLI, by calling any contract-related `jamb` command and providing the contract's symbolic identifier (the type-level string used to define its contract synonym).

### **Recap:**
* Jambhala exports contain any contract-related data desired to be made accessible to the `jamb` CLI.

## **5. (Optional) Define Emulator Component**
  * 5a. Declare an **endpoint class instance** for the contract synonym (*`ValidatorEndpoints`*/*`MintingEndpoint`*).
  * 5b. Define the associated **endpoint parameter(s)**: 
    * *`GiveParam`* & *`GrabParam`* for spending validators
    * *`MintParam`* for minting policies
  * 5c. Define the **endpoint method(s)**:
    * `give :: GiveParam contract -> ContractM contract ()` for spending validators
    * `grab :: GrabParam contract -> ContractM contract ()` for spending validators
    * `mint :: MintParam contract -> ContractM contract ()` for minting policies
  * 5d. Define the **emulator test** (`:: EmulatorTest`)
  ### **Recap:**
  * An **emulator component** consists of:
    * An **endpoint class instance** 
    * An **emulator test**
  * An **endpoint class instance**:
    * Is defined for the contract synonym.
    * Which class is instantiated depends on the kind of script: 
      * *`ValidatorEndpoints`* class for spending validators.
      * *`MintingEndpoint`* class for minting policies.
    * Instances consist of:
      * One or two **associated endpoint parameters**. These are open-ended data types tied to the class, which serve as the input(s) to the class's endpoint method(s). They are declared within the instance by applying a *type family* (type-level function) to the contract synonym, and defining one or more *constructors*.
      * One or two **endpoint methods**. These are functions containing instructions to perform within the emulator environment.
    * Endpoint methods are computations within an opaque monadic environment called *`ContractM`* (a Jambhala specialization of the *`Contract`* monad from Plutus). The internals of this context are not critical to understand: it can be conceived as a black box behaving similarly to the *`IO`* monad.
    * Endpoint methods are not invoked directly, but are called internally by related **endpoint actions**. 
    * Endpoint actions are predefined utility functions that are applied to contract-specific data in order to execute emulator effects.
  * An **emulator test** is a package of data that can be exported and consumed by the Jambhala framework's CLI (using the `jamb -t` command) to print test results in the terminal.
  * A test is assembled by calling the `initEmulator` utility function, which requires the following data:
    1. The contract synonym, provided as a *type application* (in-line annotation to clarify an ambiguous type).
    2. The number of mock wallets required by the test is specified as an integer literal.
    3. A list of contract actions, which are constructed using pre-defined utility functions.